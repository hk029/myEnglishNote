# 12 取样问题

## 问题提出

> 输入包含整数m和n，其中m<n。输出是0~n-1范围内的m个随机证书的有序序列表，不允许重复。从概率的角度来说，我们希望得到没有重复的有序选择，其中每个选择出现的概率相等。

假设我现在有两个函数：

- `bigrand()` ：返回很大的随机整数
- `randint(i,j)` ： 返回i..j范围内均匀选择的随机整数

## 思路1

Knuth大神的思路，就是**概率**。假设当前概率为：m/n （m < n）:  

```c
if (bigrand() % n) < m
```

如果选一个数的概率是2/5，那很简单：

```c
if (bigrand() % 5) < 2
```



我们知道，第一个数选择的概率是：m/n，有两种情况：

- 选中：n,m 均-1

- 没选中：n-1

  ​

### 正确性

为什么它能恰好选出m个？很简单：

- 如果m = 0，那判断永远不会成立，即不会选出比m多的数
- 如果n <= m，那判断永远成立，即不会选出比m少的数



### 代码

这里改了一下for循环，从后往前（符合n-1的思路）

```c
void genknuth(int m, int n){
  for(int i = n;i > 1 ;i--){
      if( (bigrand() % i ) < m){
        do sth;
        m--;
      }
    }
}
```

当然，这里不对m判断也是可以的，因为一旦m为负之后，判断就永远不可能满足了。当然你也可以判断m，让循环早点终止。



###  缺点

每个数都要对概率做一次运算，当n很大的时候，**耗时**



## 思路2

或者还有个更简单的思路，如果我能保证**完全随机**的情况下，不断随机直接随机m次，然后存入set就行了（保证不重复）

```c
void genset(int m, int n){
  set<int> S;
  while(S.size() < m)
    S.insert(bigrand()%n);
  
  Set<int>::iterator i;
  for(i = S.begin(); i != S.end(); ++i)
    cout<< *i << "\n";
}

```

### 优点

处理速度快，由于C++标准的模版库规范中每次插入操作都是O(logm)时间内完成

### 缺点

空间开销较大

## 思路3

有没有别的方法？其实还有一个很本能的思路：如果我能保证把所有的数都**彻底打乱**，那我只用从中随便选m个就行（最简单选0~m就行），打乱算法Knuth也给了一种：

```c
for i = [0,n)
    swap(i,randint(i,n-1))
```

但是实际上，我们**只要打乱前m个**就行了

```c++
void genshuf(int m , int n){
  int i,j;
  int *x = new int[n];
  for(i = 0;i < n;i++)
  	x[i] = i;
  for (i = 0;i < m;i++){
    j = randint(i, n-1);
    swap(x[i],x[j]);
  }
  sort(x,x+m);
  for(i = 0;i < m;i++)
  	cout<<x[i]<<"\n";
 
}
```

### 优点

这个算法可以看作上一个算法的变种，通过显式表示未选中集合x[i...n-1]，避免了对新元素是否选中做测试

### 缺点

不幸的是，这个算法要O(n)的时间和空间，通常性能不如Knuth算法





