# 12 取样问题

## 问题提出

> 输入包含整数m和n，其中m<n。输出是0~n-1范围内的m个随机证书的有序序列表，不允许重复。从概率的角度来说，我们希望得到没有重复的有序选择，其中每个选择出现的概率相等。

假设我现在有两个函数：

- `bigrand()` ：返回很大的随机整数
- `randint(i,j)` ： 返回i..j范围内均匀选择的随机整数

## 思路1

Knuth大神的思路，就是**概率**。假设当前概率为：m/n （m < n）:  

```c
if (bigrand() % n) < m
```

如果选一个数的概率是2/5，那很简单：

```c
if (bigrand() % 5) < 2
```



我们知道，第一个数选择的概率是：m/n，有两种情况：

- 选中：n,m 均-1

- 没选中：n-1

  ​

### 正确性

为什么它能恰好选出m个？很简单：

- 如果m = 0，那判断永远不会成立，即不会选出比m多的数
- 如果n <= m，那判断永远成立，即不会选出比m少的数



### 代码

这里改了一下for循环，从后往前（符合n-1的思路）

```c
void genknuth(int m, int n){
  for(int i = n;i > 1 ;i--){
      if( (bigrand() % i ) < m){
        do sth;
        m--;
      }
    }
}
```

当然，这里不对m判断也是可以的，因为一旦m为负之后，判断就永远不可能满足了。当然你也可以判断m，让循环早点终止。



###  缺点

每个数都要对概率做一次运算，当n很大的时候，**耗时**





## 思路2

有没有别的方法？其实还有一个很本能的思路：如果我能保证把所有的数都**彻底打乱**，那我只用从中随便选m个就行（最简单选0~m就行），打乱算法Knuth也给了一种：

```c
for i = [0,n)
    swap(i,randint(i,n-1))
```









或者还有个更简单的思路，如果我能保证**完全随机**的情况下，不断随机直接随机m次，然后存入set就行了（保证不重复）



