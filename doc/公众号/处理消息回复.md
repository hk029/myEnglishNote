# 处理消息回复

首先，我们要知道，微信平台给我们发送消息采用的是`POST`方法，验证采用的是`GET`方法。

其次，微信采用的是很蛋疼的`XML`格式传输数据的，而不是`JSON`格式（如果中文较多，XML更加节省资源）



## 步骤

1. 处理POST类型的控制逻辑，接受XML数据包
2. 解析XML数据包，获取回复类型
3. 拼接定义好的消息
4. 包装XML格式
5. 5秒内返回回去



## 处理POST逻辑

重写中间件，通过判断`this.method`，来把`POST`逻辑分离出来

```javascript
return function *(next) {
    var token = opts.token;
    console.log(this.query);
    var that = this;

    var sigature = this.query.signature;
    var nonce = this.query.nonce;
    var timestamp = this.query.timestamp;
    var echostr = this.query.echostr;
    var str = [token, timestamp, nonce].sort().join('');
    var sha = sha1(str);
    if(this.method === 'GET')
    {
        if (sha === sigature) {
            this.body = echostr + '';
        }
        else {
            this.body = 'wrong';
        }
    }
    else if(this.method === 'POST')
    {
    ……
```



## 解析XML格式

所以，为了解析XML格式，我们需要用到以下的几个模块

###　raw-body模块

> 这个模块可以把this上的request对象去拼接它的数据，最终可以拿到一个buffer的xml数据

我们看一看这个getRawBody模块的内容，它可以传入3个参数：

- stream : 流对象，
- options : 选项参数（可选）一般可以包含3个参数：`length`,`limit`,`encoding`
- callback：如果传入了函数，则采用回调的方式，**否则默认使用promise返回**`

```javascript
function getRawBody (stream, options, callback) {
  var done = callback
  var opts = options || {}

  if (options === true || typeof options === 'string') {
    // short cut for encoding
    opts = {
      encoding: options
    }
  }

  if (typeof options === 'function') {
    done = options
    opts = {}
  }

  // validate callback is a function, if provided
  if (done !== undefined && typeof done !== 'function') {
    throw new TypeError('argument callback must be a function')
  }

  // require the callback without promises
  if (!done && !global.Promise) {
    throw new TypeError('argument callback is required')
  }

  // get encoding
  var encoding = opts.encoding !== true
    ? opts.encoding
    : 'utf-8'

  // convert the limit to an integer
  var limit = bytes.parse(opts.limit)

  // convert the expected length to an integer
  var length = opts.length != null && !isNaN(opts.length)
    ? parseInt(opts.length, 10)
    : null

  if (done) {
    // classic callback style
    return readStream(stream, encoding, length, limit, done)
  }

  return new Promise(function executor (resolve, reject) {
    readStream(stream, encoding, length, limit, function onRead (err, buf) {
      if (err) return reject(err)
      resolve(buf)
    })
  })
}
```



这样，我们就知道如何使用了：

首先，引入raw-body模块

```javascript
var getRawBody = require('raw-body');
```

然后设置参数，yield rawbody函数

```javascript
var data = yield getRawBody(this.req,{
    length: this.length,
    limit:'1mb',
    encoding:this.charset
})
```

然后我们可以打印出来看看：

```javascript
console.log(data.toString())
```

打印出来结果如下：

    { xml: 
    { ToUserName: [ 'gh_0aeffc34d452' ],
     FromUserName: [ 'o5ywkwrKFwTfp5XHcYBmCspESWMc' ],
     CreateTime: [ '1476086698' ],
     MsgType: [ 'text' ],
     Content: [ '1' ],
     MsgId: [ '6339744094387623882' ] } }
我们需要对这个结构进行解析，最好能把XML转换成json格式